{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Nimble User Guide","text":"<p>Nimble is the default package manager for the Nim programming language.</p> <p>It can search for Nim packages, install dependencies, create new packages and upload them to the official package list (see nimble.directory), and much more.</p>"},{"location":"index.html#install-nimble","title":"Install Nimble","text":"<p>Nimble is bundled with Nim. This means that you should have Nimble installed already, as long as you have the latest version of Nim installed as well. Because of this, it is very likely that you do not need to install Nimble manually.</p> <p>In case you still want to install Nimble manually, you can follow these installation instructions.</p>"},{"location":"index.html#system-requirements","title":"System Requirements","text":"<p>Nimble has some runtime dependencies on external tools, these tools are used to download Nimble packages. For instance, if a package is hosted on GitHub, you need to have git installed and added to your environment <code>PATH</code>. The same goes for Mercurial repositories on Bitbucket. Nimble packages are typically hosted in Git repositories so you may be able to get away without installing Mercurial.</p> <p>Warning</p> <p>Ensure that you have a fairly recent version of <code>Git</code> installed. Current minimal supported version is <code>Git 2.22</code> from 2019-06-07.</p>"},{"location":"index.html#getting-started","title":"Getting Started","text":"<ul> <li> <p>If you wish to explore existing Nim packages and install some of them, follow the using packages guide.</p> </li> <li> <p>If you would like to create your own Nimble package, the create Nimble packages guide is for you.</p> </li> <li> <p>To learn more about how to use the new workflow with <code>nimble develop</code>, follow the Nimble develop guide.</p> </li> </ul>"},{"location":"create-packages.html","title":"Creating Nimble packages","text":"<p>In this guide you will find the information on how to create and publish new Nimble packages.</p>"},{"location":"create-packages.html#nimble-init","title":"<code>nimble init</code>","text":"<p>The easiest and recommended way to start a new Nimble project is to run <code>nimble init</code> in the directory in which you want to create a package, and follow the steps in the wizard.</p> <pre><code>$ nimble init\n      Info: Package initialisation requires info which could not be inferred.\n        ... Default values are shown in square brackets, press\n        ... enter to use them.\n      Using \"myPackage\" for new package name\n      Using username for new package author\n      Using \"src\" for new package source directory\n    Prompt: Package type?\n        ... Library - provides functionality for other packages.\n        ... Binary  - produces an executable for the end-user.\n        ... Hybrid  - combination of library and binary\n        ... For more information see https://goo.gl/cm2RX5\n     Select Cycle with 'Tab', 'Enter' when done\n   Choices:&gt; library &lt;\n             binary  \n             hybrid  \n</code></pre> <p>The first choice you have to make is the type of your package. The differences between those three options are outlined in this document.</p> <p>After that, the wizard asks you about the version number of your package (default: 0.1.0), a package description, a license you want to use and the lowest Nim version that your package is compatible with. You can press enter to use the provided default answer for each question.</p> <pre><code>    Prompt: Initial version of package? [0.1.0]\n    Answer: \n    Prompt: Package description? [A new awesome nimble package]\n    Answer: Check if a number is odd.         \n    Prompt: Package License?\n        ... This should ideally be a valid SPDX identifier. See https://spdx.org/licenses/.\n     Select Cycle with 'Tab', 'Enter' when done\n    Answer: MIT\n    Prompt: Lowest supported Nim version? [2.1.1]\n    Answer: 2.0.0\n   Success: Package myPackage created successfully\n</code></pre> <p>After the wizard completes, the structure of your directory looks like this:</p> <pre><code>.\n\u251c\u2500\u2500 myPackage.nimble\n\u251c\u2500\u2500 src\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 myPackage\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 submodule.nim\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 myPackage.nim\n\u2514\u2500\u2500 tests\n    \u251c\u2500\u2500 config.nims\n    \u2514\u2500\u2500 test1.nim\n</code></pre> <p>The answers you provided are stored in the <code>.nimble</code> file:</p> <pre><code># Package\n\nversion       = \"0.1.0\"\nauthor        = \"username\"\ndescription   = \"Check if a number is odd.\"\nlicense       = \"MIT\"\nsrcDir        = \"src\"\n\n\n# Dependencies\n\nrequires \"nim &gt;= 2.0.0\"\n</code></pre>"},{"location":"create-packages.html#project-structure","title":"Project structure","text":"<p>For a package named <code>foobar</code>, the recommended project structure is the following:</p> <pre><code>.                   # The root directory of the project\n\u251c\u2500\u2500 LICENSE\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 foobar.nimble   # The project .nimble file\n\u2514\u2500\u2500 src\n    \u2514\u2500\u2500 foobar.nim  # Imported via `import foobar`\n\u2514\u2500\u2500 tests           # Contains the tests\n    \u251c\u2500\u2500 config.nims\n    \u251c\u2500\u2500 tfoo1.nim   # First test\n    \u2514\u2500\u2500 tfoo2.nim   # Second test\n</code></pre> <p>Note</p> <p>When source files are placed in a <code>src</code> directory, the <code>.nimble</code> file must contain a <code>srcDir = \"src\"</code> directive. The <code>nimble init</code> command takes care of that for you.</p> <p>When introducing more modules into your package, you should place them in a separate directory named <code>foobar</code> (i.e. your package's name). For example:</p> <pre><code>.\n\u251c\u2500\u2500 ...\n\u251c\u2500\u2500 foobar.nimble\n\u251c\u2500\u2500 src\n\u2502   \u251c\u2500\u2500 foobar\n\u2502   \u2502   \u251c\u2500\u2500 utils.nim   # Imported via `import foobar/utils`\n\u2502   \u2502   \u2514\u2500\u2500 common.nim  # Imported via `import foobar/common`\n\u2502   \u2514\u2500\u2500 foobar.nim      # Imported via `import foobar`\n\u2514\u2500\u2500 ...\n</code></pre> <p>You may wish to hide certain modules in your package from the users. Create a <code>private</code> directory for that purpose. For example:</p> <pre><code>.\n\u251c\u2500\u2500 ...\n\u251c\u2500\u2500 foobar.nimble\n\u251c\u2500\u2500 src\n\u2502   \u251c\u2500\u2500 foobar\n\u2502   \u2502   \u251c\u2500\u2500 private\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 hidden.nim  # Imported via `import foobar/private/hidden`\n\u2502   \u2502   \u251c\u2500\u2500 utils.nim\n\u2502   \u2502   \u2514\u2500\u2500 common.nim\n\u2502   \u2514\u2500\u2500 foobar.nim\n\u2514\u2500\u2500 ...\n</code></pre>"},{"location":"create-packages.html#nimble-file","title":"<code>.nimble</code> file","text":"<p>As seen above, running <code>nimble init</code> creates a basic <code>.nimble</code> file. It can be modified to add more dependencies and/or create custom tasks, etc.</p>"},{"location":"create-packages.html#dependencies","title":"Dependencies","text":"<p>If your package relies on other dependencies, you need to add them to the <code>.nimble</code> file. Nimble currently supports the installation of packages from a local directory, a Git repository and a mercurial repository. </p> <pre><code>...\n\n# Dependencies\n\nrequires \"nim &gt;= 2.0.0\"\nrequires \"fizzbuzz == 1.0\"\nrequires \"https://github.com/user/pkg#5a54b5e\"\nrequires \"foobar#head\"\n</code></pre> <p>Versions of cloned packages via Git or Mercurial are determined through the repository's tags. When installing a package that needs to be downloaded, Nimble will check the cloned repository's tags list.</p> <ul> <li>If no tags exist, Nimble will simply install the <code>HEAD</code> of the repository.</li> <li>If tags exist, Nimble will attempt to look for tags that resemble versions (e.g. <code>v0.1</code>) and will then find the latest version out of the available tags, once it does so it will install the package after checking out the latest version.</li> </ul> <p>You can force the installation of the <code>HEAD</code> of the repository by specifying <code>#head</code> after the package name in your dependency list.</p> <p>There are several version selector operators you can use:</p> Operator Meaning <code>==</code> Install the exact version. <code>&gt;</code> Install higher version. <code>&lt;</code> Install lower version. <code>&gt;=</code> Install at least the provided version. <code>&lt;=</code> Install at most the provided version. <code>^=</code> Install the latest compatible version according to semver. <code>~=</code> Install the latest version by increasing the last given digit to the highest version. <p>Here are some examples of the <code>^=</code> and <code>~=</code> operators:</p> <pre><code>requires \"nim ^= 1.2.2\"    # nim &gt;= 1.2.2 &amp; &lt; 2.0.0\nrequires \"nim ~= 1.2.2\"    # nim &gt;= 1.2.2 &amp; &lt; 1.3.0\nrequires \"jester ^= 0.4.1\" # jester &gt;= 0.4.1 &amp; &lt; 0.5.0\nrequires \"jester ~= 0.4.1\" # jester &gt;= 0.4.1 &amp; &lt; 0.5.0\nrequires \"jester ~= 0.4\"   # jester &gt;= 0.4.0 &amp; &lt; 1.0.0\nrequires \"choosenim ~= 0\"  # choosenim &gt;= 0.0.0 &amp; &lt; 1.0.0\nrequires \"choosenim ^= 0\"  # choosenim &gt;= 0.0.0 &amp; &lt; 1.0.0\n</code></pre>"},{"location":"create-packages.html#nimscript-compatibility","title":"NimScript compatibility","text":"<p>The <code>.nimble</code> file is very flexible because it is interpreted using NimScript.</p> <p>Because of Nim's flexibility, the definitions remain declarative, with the added ability to use the Nim language to enrich your package specification. For example, you can define dependencies for specific platforms using Nim's <code>when</code> statement:</p> <pre><code>when defined(macosx):\n  requires \"libcurl &gt;= 1.0.0\"\n\nwhen defined(windows):\n  requires \"puppy 1.5.4\"\n</code></pre>"},{"location":"create-packages.html#nimble-tasks","title":"<code>nimble tasks</code>","text":"<p>Another great feature of <code>.nimble</code> file is the ability to define custom Nimble package-specific commands:</p> <pre><code>task hello, \"This is a hello task\":\n  echo \"Hello World!\"\n</code></pre> <p>You can then execute <code>nimble hello</code>, which will result in the following output:</p> <pre><code>$ nimble hello\n  Verifying dependencies for myPackage@0.1.0\n  Executing task hello in /home/username/myPackage/myPackage.nimble\nHello world\n</code></pre> <p>You can also check what tasks are supported by the package in the current directory by using the <code>nimble tasks</code> command, for example:</p> <pre><code>$ nimble tasks\nhello     This is a hello task\n</code></pre> <p>You can place any Nim code inside these tasks, as long as that code does not access the FFI. The nimscript module in Nim's standard library defines additional functionality, such as the ability to execute external processes which makes this feature very powerful.</p> <p>Nimble provides an API that adds even more functionality. For example, you can specify pre- and post- hooks for any Nimble command (including commands that you define yourself). To do this you can add something like the following:</p> <pre><code>before hello:\n  echo \"About to call hello!\"\n</code></pre> <p>That will result in the following output when <code>nimble hello</code> is executed:</p> <pre><code>$ nimble hello\n  Verifying dependencies for myPackage@0.1.0\nAbout to call hello!\n  Executing task hello in /home/username/myPackage/myPackage.nimble\nHello world\n</code></pre> <p>Similar to this, an <code>after</code> block is also available for post hooks, which are executed after Nimble finished executing a command. You can also return <code>false</code> from these blocks to stop further execution.</p> <p>Tasks support two kinds of flags: <code>nimble &lt;compflags&gt; task &lt;runflags&gt;</code>.</p> <p>Compile flags are those specified before the task name and are forwarded to the Nim compiler that runs the <code>.nimble</code> task. This enables setting <code>--define:xxx</code> values that can be checked with <code>when defined(xxx)</code> in the task, and other compiler flags that are applicable in Nimscript mode.</p> <p>Run flags are those after the task name and are available as command-line arguments to the task. They can be accessed as usual from <code>commandLineParams: seq[string]</code>.</p> <p>In order to forward compiler flags to <code>exec(\"nim ...\")</code> calls executed within a custom task, the user needs to specify these flags as run flags which will then need to be manually accessed and forwarded in the task.</p>"},{"location":"create-packages.html#nimble-test","title":"<code>nimble test</code>","text":"<p>Nimble offers a pre-defined <code>test</code> task that compiles and runs all files in the <code>tests</code> directory beginning with letter <code>t</code> in their filename. Nim flags provided to <code>nimble test</code> will be forwarded to the compiler when building the tests.</p> <p>If we run <code>nimble test</code> on our example project created in sections above, the default <code>tests/test1.nim</code> (pre-populated with one test) will run with the following output:</p> <pre><code>$ nimble test\n  Verifying dependencies for myPackage@0.1.0\n  Compiling /home/username/myPackage/tests/test1 (from package myPackage) using c backend\n[OK] can add\n   Success: Execution finished\n   Success: All tests passed\n</code></pre> <p>You may wish to override the default <code>test</code> task in your <code>.nimble</code> file. Here is a real-world example of a custom <code>test</code> task, which runs tests from seven different test files:</p> <pre><code>task test, \"General tests\":\n  for file in [\"tsources.nim\", \"tblocks.nim\", \"tnimib.nim\", \"trenders.nim\"]:\n    exec \"nim r --hints:off tests/\" &amp; file\n  for file in [\"tblocks.nim\", \"tnimib.nim\", \"trenders.nim\"]:\n    exec \"nim r --hints:off -d:nimibCodeFromAst tests/\" &amp; file\n</code></pre>"},{"location":"create-packages.html#nimble-c","title":"<code>nimble c</code>","text":"<p>The <code>c</code> (or <code>compile</code>, <code>js</code>, <code>cc</code>, <code>cpp</code>) command can be used by developers to compile individual modules inside their package. All options passed to Nimble will also be passed to the Nim compiler during compilation. For example:</p> <p>Nimble will use the backend specified in the package's <code>.nimble</code> file if the command <code>c</code> or <code>compile</code> is specified. The more specific <code>js</code>, <code>cc</code>, <code>cpp</code> can be used to override that.</p>"},{"location":"create-packages.html#nimble-build","title":"<code>nimble build</code>","text":"<p>The <code>build</code> command is mostly used by developers who want to test building their <code>.nimble</code> package. This command will build the package with default flags, i.e. a debug build which includes stack traces but no GDB debug information. The <code>install</code> command will build the package in release mode instead.</p> <p>Nim flags provided to <code>nimble build</code> will be forwarded to the compiler. Such compiler flags can be made persistent by using Nim configuration files.</p>"},{"location":"create-packages.html#nimble-run","title":"<code>nimble run</code>","text":"<p>The <code>run</code> command can be used to build and run any binary specified in your package's <code>bin</code> list. The binary needs to be specified after any compilation flags if there are several binaries defined. Any flags after the binary or <code>--</code> are passed to the binary when it is run. It is possible to run a binary from some dependency package. To do this pass the <code>--package, -p</code> option to Nimble. For example:</p> <pre><code>nimble --package:foo run &lt;compilation_flags&gt; bar &lt;run_flags&gt;\n</code></pre>"},{"location":"create-packages.html#nimble-check","title":"<code>nimble check</code>","text":"<p>The <code>check</code> command will read your package's <code>.nimble</code> file. It will then verify that the package's structure is valid.</p> <p>Example:</p> <pre><code>$ nimble check\n    Error: Package 'x' has an incorrect structure.\n    It should contain a single directory hierarchy for source files, named 'x',\n    but file 'foobar.nim' is in a directory named 'incorrect' instead.\n    This will be an error in the future.\n    Hint: If 'incorrect' contains source files for building 'x', rename it to 'x'.\n    Otherwise, prevent its installation by adding `skipDirs = @[\"incorrect\"]`\n    to the .nimble file.\n  Failure: Validation failed\n</code></pre> <p>When using the <code>check</code> command, the development mode dependencies are also validated against the lock file. The following reasons for validation failure are possible:</p> <ul> <li>The package directory is not under version control.</li> <li>The package working copy directory is not in clean state.</li> <li>Current VCS revision is not pushed on any remote.</li> <li>The working copy needs sync.</li> <li>The working copy needs lock.</li> <li>The working copy needs merge or re-base.</li> </ul>"},{"location":"create-packages.html#nimble-install","title":"<code>nimble install</code>","text":"<p>While <code>nimble install &lt;packageName&gt;</code> is used to download and install an existing package (see this guide), it can also be used for locally testing or developing a Nimble package by leaving out the package name parameter. Your current working directory must be a Nimble package and contain a valid <code>package.nimble</code> file.</p> <p>Nimble will install the package residing in the current working directory when you don't specify a package name and the directory contains a <code>package.nimble</code> file. This can be useful for developers who are locally testing their <code>.nimble</code> files before submitting them to the official package list.</p> <p>Dependencies required for developing or testing a project can be installed by passing <code>--depsOnly</code> without specifying a package name. Nimble will then install any missing dependencies listed in the package's <code>package.nimble</code> file in the current working directory. Note that dependencies will be installed globally.</p> <p>For example, to install the dependencies:</p> <pre><code>$ nimble install --depsOnly\n</code></pre>"},{"location":"create-packages.html#nimble-publish","title":"<code>nimble publish</code>","text":"<p>Publishing packages isn't a requirement, but doing so allows people to associate a specific name to a URL pointing to your package. This mapping is stored in the official packages repository.</p> <p>This repository contains a <code>packages.json</code> file that lists all the published packages. It contains a set of package names with associated metadata. You can read more about this metadata in the readme for the packages repository.</p> <p>To publish your package, you can do it in two different ways:</p> <ul> <li> <p>Semi-automatically, by running <code>nimble publish</code>, which requires a valid GitHub account with a personal access token.    The token is stored in <code>$nimbleDir/github_api_token</code>, which can be replaced if you need to update/replace your token.</p> </li> <li> <p>Manually, by forking the packages repository, adding an entry into the <code>packages.json</code> file for your packages, and creating a pull request with your changes.</p> </li> </ul> <p>You need to do this only once, i.e. no need to do it every time you increase the version of your package.</p>"},{"location":"create-packages.html#releasing-a-new-version","title":"Releasing a new version","text":"<p>Version releases are done by creating a tag in your Git or Mercurial repository.</p> <p>Whenever you want to release a new version, you should remember to first increment the version in your <code>.nimble</code> file and commit your changes. Only after that is done should you tag the release.</p> <p>To summarize, the steps for release are:</p> <ol> <li>Increment the version in your <code>.nimble</code> file.</li> <li>Commit your changes.</li> <li>Tag your release, by for example running <code>git tag v0.2.0</code>.</li> <li>Push your tags and commits.</li> </ol> <p>Once the new tag is in the remote repository, Nimble will be able to detect the new version.</p>"},{"location":"create-packages.html#git-version-tagging","title":"Git Version Tagging","text":"<p>Use dot-separated numbers to represent the release version in the git tag label.  Nimble will parse these git tag labels to know which versions of a package are published.</p> <pre><code>v0.2.0        # 0.2.0\nv1            # 1\nv1.2.3-zuzu   # 1.2.3\nfoo-1.2.3.4   # 1.2.3.4\n</code></pre>"},{"location":"install-nimble.html","title":"Installing Nimble","text":"<p>Nimble is bundled with Nim. This means that you should have Nimble installed already, as long as you have the latest version of Nim installed as well. Because of this, it is very likely that you do not need to install Nimble manually.</p> <p>In case you still want to install Nimble manually, you can follow these installation instructions:</p>"},{"location":"install-nimble.html#using-koch","title":"Using koch","text":"<p>The <code>koch</code> tool is included in the Nim distribution and repository. Simply navigate to the location of your Nim installation and execute the following command to compile and install Nimble:</p> <pre><code>./koch nimble\n</code></pre> <p>This will clone the Nimble repository, compile Nimble and copy it into Nim's bin directory.</p>"},{"location":"install-nimble.html#using-nimble","title":"Using Nimble","text":"<p>In most cases you will already have Nimble installed, you can install a newer version of Nimble by simply running the following command:</p> <pre><code>nimble install nimble\n</code></pre> <p>This will download the latest release of Nimble and install it on your system.</p> <p>Note that you must have <code>~/.nimble/bin</code> in your <code>PATH</code> for this to work. If you're using choosenim then you likely already have this set up correctly.</p>"},{"location":"nimble-reference.html","title":"<code>.nimble</code> file reference","text":""},{"location":"nimble-reference.html#package","title":"[Package]","text":""},{"location":"nimble-reference.html#required","title":"Required","text":"<ul> <li><code>name</code> - The name of the package. (This is not required in the new NimScript format)</li> <li><code>version</code> - The current version of this package. This should be incremented   before tagging the current version using <code>git tag</code> or <code>hg tag</code>.</li> <li><code>author</code> - The name of the author of this package.</li> <li><code>description</code> - A string describing the package.</li> <li><code>license</code> - The name of the license under which this package is licensed.</li> </ul>"},{"location":"nimble-reference.html#optional","title":"Optional","text":"<ul> <li><code>skipDirs</code> - A list of directory names which should be skipped during   installation, separated by commas.</li> <li><code>skipFiles</code> - A list of file names which should be skipped during   installation, separated by commas.</li> <li><code>skipExt</code> - A list of file extensions which should be skipped during   installation, the extensions should be specified without a leading <code>.</code>, and   should be separated by commas.</li> <li><code>installDirs</code> - A list of directories which should exclusively be installed.   If this option is specified nothing else will be installed except the dirs   listed here, the files listed in <code>installFiles</code>, the files which share the   extensions listed in <code>installExt</code>, the <code>.nimble</code> file, and, if <code>bin</code> or <code>namedBin</code> is specified, the binary.   Separated by commas.</li> <li><code>installFiles</code> - A list of files which should be exclusively installed.   This complements <code>installDirs</code> and <code>installExt</code>. Only the files listed   here, directories listed in <code>installDirs</code>, files which share the extension   listed in <code>installExt</code>, the <code>.nimble</code> file and the binary (if <code>bin</code> or <code>namedBin</code>   is specified) will be installed. Separated by commas.</li> <li><code>installExt</code> - A list of file extensions which should be exclusively   installed. This complements <code>installDirs</code> and <code>installFiles</code>.   Separated by commas.</li> <li><code>srcDir</code> - Specifies the directory which contains the <code>.nim</code> source files.   Default: The directory in which the <code>.nimble</code> file resides; i.e. root dir of   the package.</li> <li><code>binDir</code> - Specifies the directory where <code>nimble build</code> will output   binaries.   Default: The directory in which the <code>.nimble</code> file resides; i.e.   root dir of the package.</li> <li><code>bin</code> - A list of files which should be built separated by commas with   no file extension required. This option turns your package into a binary package.   Nimble will build the files specified and install them appropriately.</li> <li><code>namedBin</code> - A list of <code>name:value</code> files which should be built with specified   name, no file extension required. This option turns your package into a   binary package. Nimble will build the files specified and install them appropriately.   <code>namedBin</code> entries override duplicates in <code>bin</code>.</li> <li><code>backend</code> - Specifies the backend which will be used to build the files   listed in <code>bin</code>. Possible values include: <code>c</code>, <code>cc</code>, <code>cpp</code>, <code>objc</code>,   <code>js</code>.   Default: <code>c</code>.</li> </ul>"},{"location":"nimble-reference.html#depsdependencies","title":"[Deps]/[Dependencies]","text":""},{"location":"nimble-reference.html#optional_1","title":"Optional","text":"<ul> <li><code>requires</code> - Specifies a list of package names with an optional version   range separated by commas.   Example: <code>nim &gt;= 0.10.0, jester</code>; with this value your package will   depend on <code>nim</code> version 0.10.0 or greater and on any version of <code>jester</code>.</li> </ul>"},{"location":"package-types.html","title":"Nimble package types","text":"<p>When running <code>nimble init</code> wizard, you will have three different package types to choose from. Here are their specifications and differences.</p>"},{"location":"package-types.html#libraries","title":"Libraries","text":"<p>Library packages are likely the most popular form of Nimble packages. They are meant to be used by other library or binary packages.</p> <p>When Nimble installs a library, it will copy all of its files into <code>$nimbleDir/pkgs2/pkgname-ver-checksum</code>. It's up to the package creator to make sure that the package directory layout is correct, this is so that users of the package can correctly import the package.</p> <p>It is suggested that the layout be as follows. The directory layout is determined by the nature of your package, that is, whether your package exposes only one module or multiple modules.</p> <p>If your package exposes only a single module, then that module should be present in the source directory of your Git repository and should be named whatever your package's name is. A good example of this is the jester package which exposes the <code>jester</code> module. In this case, the jester package is imported with <code>import jester</code>.</p> <p>If your package exposes multiple modules then the modules should be in a <code>PackageName</code> directory. This will allow for a certain measure of isolation from other packages which expose modules with the same names. In this case, the package's modules will be imported with <code>import PackageName/module</code>.</p> <p>Here's a simple example multi-module library package called <code>kool</code>:</p> <pre><code>.\n\u251c\u2500\u2500 kool\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 useful.nim\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 also_useful.nim\n\u2514\u2500\u2500 kool.nimble\n</code></pre> <p>In regards to modules which you do not wish to be exposed. You should place them in a <code>PackageName/private</code> directory. Your modules may then import these private modules with <code>import PackageName/private/module</code>. This directory structure may be enforced in the future.</p> <p>All files and folders in the directory where the <code>.nimble`` file resides will be copied as-is. You can however skip some directories or files by setting the</code>skipDirs<code>,</code>skipFiles<code>or</code>skipExt<code>options in your .nimble file. Directories and files can also be specified on a *whitelist* basis. If you specify either of</code>installDirs<code>,</code>installFiles<code>or</code>installExt`, then Nimble will only install the files specified.</p>"},{"location":"package-types.html#binary-packages","title":"Binary packages","text":"<p>These are application packages which require building prior to installation. A package is automatically a binary package as soon as it sets at least one <code>bin</code> value, like so:</p> <pre><code>bin = @[\"main\"]\n</code></pre> <p>In this case when <code>nimble install</code> is invoked, Nimble will build the <code>main.nim</code> file, copy it into <code>$nimbleDir/pkgs2/pkgname-ver-checksum/</code> and subsequently create a symlink to the binary in <code>$nimbleDir/bin/</code>. On Windows, a stub <code>.cmd</code> file is created instead.</p> <p>The binary can be named differently than the source file with the <code>namedBin</code> table:</p> <pre><code>namedBin[\"main\"] = \"mymain\"\nnamedBin = {\"main\": \"mymain\", \"main2\": \"other-main\"}.toTable()\n</code></pre> <p>Note that <code>namedBin</code> entries override duplicates in <code>bin</code>.</p> <p>Dependencies are automatically installed before building. It's a good idea to test that the dependencies you specified are correct by running <code>nimble build</code> or <code>nimble install</code> in the directory of your package.</p>"},{"location":"package-types.html#hybrids","title":"Hybrids","text":"<p>Binary packages will not install .nim files so include <code>installExt = @[\"nim\"]</code> in your <code>.nimble</code> file if you intend for your package to be a hybrid binary/library combo.</p> <p>Historically, binaries that shared the name of a <code>pkgname</code> directory that contains additional <code>.nim</code> files required workarounds. This is now handled behind the scenes by appending an <code>.out</code> extension to the binary and is transparent to commands like <code>nimble run</code> or symlinks which can still refer to the original binary name.</p>"},{"location":"use-packages.html","title":"Use existing Nimble packages","text":"<p>While Nim has a relatively large standard library, chances are that at some point you will want to use some 3rd party library. In the following sections, we will show you the most used <code>nimble</code> commands for that purpose.</p>"},{"location":"use-packages.html#nimble-install","title":"<code>nimble install</code>","text":"<p>The <code>install</code> command will download and install a package. You need to pass the name of the package (or packages) you want to install. If any of the packages depend on other Nimble packages Nimble will also install them. Example:</p> <pre><code>$ nimble install nake\nDownloading https://github.com/fowlmouth/nake using git\n      ...\n  Success:  nake installed successfully.\n</code></pre> <p>Nimble always fetches and installs the latest version of a package. Note that the latest version is defined as the latest tagged version in the Git (or Mercurial) repository. If the package has no tagged versions then the latest commit in the remote repository will be installed. If you already have that version installed, Nimble will ask you whether you wish to overwrite your local copy.</p>"},{"location":"use-packages.html#installing-a-specific-version","title":"Installing a specific version","text":"<p>You can force Nimble to download the latest commit from the package's repo, for example:</p> <pre><code>$ nimble install nimgame@#head\n</code></pre> <p>This is of course Git-specific, for Mercurial, use <code>tip</code> instead of <code>head</code>. A branch, tag, or commit hash may also be specified in the place of <code>head</code>.</p> <p>Instead of specifying a VCS branch, you may also specify a concrete version or a version range, for example:</p> <pre><code>$ nimble install nimgame@0.5\n$ nimble install nimgame@\"&gt; 0.5\"\n</code></pre> <p>The following version selector operators are available:</p> Operator Meaning <code>==</code> Install the exact version. <code>&gt;</code> Install higher version. <code>&lt;</code> Install lower version. <code>&gt;=</code> Install at least the provided version. <code>&lt;=</code> Install at most the provided version. <code>^=</code> Install the latest compatible version according to semver. <code>~=</code> Install the latest version by increasing the last given digit to the highest version. <p>Nim flags provided to <code>nimble install</code> will be forwarded to the compiler when building any binaries. Such compiler flags can be made persistent by using Nim configuration files.</p>"},{"location":"use-packages.html#package-urls","title":"Package URLs","text":"<p>A valid URL to a Git or Mercurial repository can also be specified, Nimble will automatically detect the type of the repository that the url points to and install it. This way, the packages which are not in the official package list can be installed.</p> <p>For repositories containing the Nimble package in a subdirectory, you can instruct Nimble about the location of your package using the <code>?subdir=&lt;path&gt;</code> query parameter. For example:</p> <pre><code>$ nimble install https://github.com/nimble-test/multi?subdir=alpha\n</code></pre>"},{"location":"use-packages.html#local-package-development","title":"Local Package Development","text":"<p>The <code>install</code> command can also be used for locally testing or developing a Nimble package by leaving out the package name parameter. Your current working directory must be a Nimble package and contain a valid <code>package.nimble</code> file.</p> <p>Nimble will install the package residing in the current working directory when you don't specify a package name and the directory contains a <code>package.nimble</code> file. This can be useful for developers who are locally testing their <code>.nimble</code> files before submitting them to the official package list. See the Create Packages guide for more info on this.</p> <p>Dependencies required for developing or testing a project can be installed by passing <code>--depsOnly</code> without specifying a package name. Nimble will then install any missing dependencies listed in the package's <code>package.nimble</code> file in the current working directory. Note that dependencies will be installed globally.</p> <p>For example to install the dependencies for a Nimble project <code>myPackage</code>:</p> <pre><code>$ cd myPackage\n$ nimble install --depsOnly\n</code></pre>"},{"location":"use-packages.html#nimble-list","title":"<code>nimble list</code>","text":"<p>If you want to list all available packages, you can use <code>nimble list</code>, but beware: it is a very long (and not very useful) list. It might be better to use <code>nimble search</code> (explained below), to search for a specific package.</p> <p>If you want to see a list of locally installed packages and their versions, use <code>--installed</code>, or <code>-i</code> for short:</p> <pre><code>$ nimble list -i\n</code></pre>"},{"location":"use-packages.html#nimble-search","title":"<code>nimble search</code>","text":"<p>If you don't want to go through the whole output of the <code>list</code> command you can use the <code>search</code> command specifying as parameters the package name and/or tags you want to filter. Nimble will look into the known list of available packages and display only those that match the specified keywords (which can be substrings). Example:</p> <pre><code>$ nimble search math\n\nlinagl:\nurl:         https://bitbucket.org/BitPuffin/linagl (hg)\ntags:        library, opengl, math, game\ndescription: OpenGL math library\nlicense:     CC0\nwebsite:     https://bitbucket.org/BitPuffin/linagl\n\nextmath:\nurl:         git://github.com/achesak/extmath.nim (git)\ntags:        library, math, trigonometry\ndescription: Nim math library\nlicense:     MIT\nwebsite:     https://github.com/achesak/extmath.nim\n\nglm:\nurl:         https://github.com/stavenko/nim-glm (git)\ntags:        opengl, math, matrix, vector, glsl\ndescription: Port of c++ glm library with shader-like syntax\nlicense:     MIT\nwebsite:     https://github.com/stavenko/nim-glm\n\n...\n</code></pre> <p>Searches are case insensitive.</p> <p>An optional <code>--ver</code> parameter can be specified to tell Nimble to query remote Git repositories for the list of versions of the packages and then print the versions. However, please note that this can be slow as each package must be queried separately.</p>"},{"location":"use-packages.html#nimbledirectory","title":"nimble.directory","text":"<p>As an alternative for <code>nimble search</code> command, you can use Nimble Directory website to search for packages.</p>"},{"location":"use-packages.html#nimble-uninstall","title":"<code>nimble uninstall</code>","text":"<p>The <code>uninstall</code> command will remove an installed package.</p> <p>Warning</p> <p>Attempting to remove a package that other packages depend on will result in an error.</p> <p>You can use the <code>--inclDeps</code> or <code>-i</code> flag to remove all dependent packages along with the package.</p> <p>Similar to the <code>install</code> command you can specify a version range, for example:</p> <pre><code>$ nimble uninstall nimgame@0.5\n</code></pre>"},{"location":"use-packages.html#nimble-refresh","title":"<code>nimble refresh</code>","text":"<p>The <code>refresh</code> command is used to fetch and update the list of Nimble packages. There is no automatic update mechanism, so you need to run this yourself if you need to refresh your local list of known available Nimble packages. Example:</p> <pre><code>$ nimble refresh\n    Copying local package list\n    Success Package list copied.\nDownloading Official package list\n    Success Package list downloaded.\n</code></pre> <p>Package lists can be specified in Nimble's config. You can also optionally supply this command with a URL if you would like to use a third-party package list.</p> <p>Some commands may remind you to run <code>nimble refresh</code> or will run it for you if they fail.</p>"},{"location":"use-packages.html#nimble-path","title":"<code>nimble path</code>","text":"<p>The <code>nimble path</code> command will show the absolute path to the installed packages matching the specified parameters. Since there can be many versions of the same package installed, this command will list all of them, for example:</p> <pre><code>$ nimble path itertools\n/home/user/.nimble/pkgs2/itertools-0.4.0-5a3514a97e4ff2f6ca4f9fab264b3be765527c7f\n/home/user/.nimble/pkgs2/itertools-0.2.0-ab2eac22ebda6512d830568bfd3052928c8fa2b9\n</code></pre>"},{"location":"workflow.html","title":"Nimble develop workflow","text":"<p>This guide assumes you are already familiar with creating a new Nimble package.</p> <p>Here you will learn how to use <code>nimble develop</code> to update the dependencies of your package. First we will list and explain all commands connected to this workflow, and at the bottom of the page you'll see the example of using them in praxis.</p>"},{"location":"workflow.html#nimble-setup","title":"<code>nimble setup</code>","text":"<p>The <code>nimble setup</code> command creates a <code>nimble.paths</code> file containing file system paths to the dependencies. It also includes the paths file in the <code>config.nims</code> file (by creating it if it does not already exist) to make them available for the compiler.</p> <p>The command also adds <code>nimble.develop</code> and <code>nimble.paths</code> files to the <code>.gitignore</code> file.</p> <p>Warning</p> <p><code>nimble.paths</code> file is user-specific and must not be committed.</p>"},{"location":"workflow.html#nimble-lock","title":"<code>nimble lock</code>","text":"<p>The <code>nimble lock</code> command will generate or update a package lock file named <code>nimble.lock</code>. This file is used for pinning the exact versions of the dependencies of the package.  The file is intended to be committed and used by other developers to ensure that exactly the same version of the dependencies is used by all developers.</p> <p>The lock files have the structure as in the following example:</p> <pre><code>{\n  \"version\": 2,\n  \"packages\": {\n     ...\n     \"chronos\": {\n      \"version\": \"3.0.2\",\n      \"vcsRevision\": \"aab1e30a726bb47c5d3f4a75a826981836cde9e2\",\n      \"url\": \"https://github.com/status-im/nim-chronos\",\n      \"downloadMethod\": \"git\",\n      \"dependencies\": [\n        \"stew\",\n        \"bearssl\",\n        \"httputils\",\n        \"unittest2\"\n      ],\n      \"checksums\": {\n        \"sha1\": \"a1cdaa77995f2d1381e8f9dc129594f2fa2ee07f\"\n      }\n    },\n    ...\n  }\n}\n</code></pre> <ul> <li><code>version</code> - JSON schema version.</li> <li><code>packages</code> - JSON object containing JSON objects for all dependencies,</li> <li><code>chronos</code> - Nested JSON object keys are the names of the dependencies packages.</li> <li><code>version</code> - The version of the dependency.</li> <li><code>vcsRevision</code> - The revision at which the dependency is locked.</li> <li><code>url</code> - The URL of the repository of the package.</li> <li><code>downloadMethod</code> - <code>git</code> or <code>hg</code> according to the type of the repository at <code>url</code>.</li> <li><code>dependencies</code> - The direct dependencies of the package.   Used for writing the reverse dependencies of the package in the <code>nimbledata.json</code> file.   Those packages' names also must be in the lock file.</li> <li><code>checksums</code> - A JSON compound object containing different checksums used for verifying that a downloaded package is exactly the same as the pinned in the lock file package.   Currently, only <code>sha1</code> checksums are supported.</li> <li><code>sha1</code> - The sha1 checksum of the package files.</li> </ul> <p>If a lock file <code>nimble.lock</code> exists, then on performing all Nimble commands which require searching for dependencies and downloading them in the case they are missing (like <code>build</code>, <code>install</code>, <code>develop</code>), it is read and its content is used to download the same version of the project dependencies by using the URL, download method and VCS revision written in it.</p> <p>The checksum of the downloaded package is compared against the one written in the lock file. In the case the two checksums are not equal then it will be printed error message and the operation will be aborted. Reverse dependencies are added for installed locked dependencies just like for any other package being locally installed.</p>"},{"location":"workflow.html#nimble-develop","title":"<code>nimble develop</code>","text":"<p>The develop command is used for putting packages in a development mode. When executed with a list of packages, it clones their repositories. If it is executed in a package directory, it adds cloned packages to the special <code>nimble.develop</code> file. This is a special file which is used for holding the paths to development mode dependencies of the current directory package. It has the following structure:</p> <pre><code>{\n    \"version\": 1,\n    \"includes\": [],\n    \"dependencies\": []\n}\n</code></pre> <ul> <li><code>version</code> - JSON schema version</li> <li><code>includes</code> - JSON array of paths to included files.</li> <li><code>dependencies</code> - JSON array of paths to Nimble packages directories.</li> </ul> <p>The format for included develop files is the same as the project's develop file.</p> <p>Develop files validation rules:</p> <ul> <li>The included develop files must be valid.</li> <li>The packages listed in the <code>dependencies</code> section and in the included develop files are required to be valid Nimble packages, but they are not required to be valid dependencies of the current project.   In the latter case, they are simply ignored.</li> <li>The develop files of the develop mode dependencies of a package are being followed and processed recursively.   Finally, only one common set of develop mode dependencies is created.</li> <li>In the final set of develop mode dependencies, it is not allowed to have more than one package with the same name but with different file system paths.</li> </ul> <p>Just as with the <code>install</code> command, a package URL may also be specified instead of a name.</p> <p>If present, the validity of the package's develop file is added to the requirements for validity of the package which is determined by <code>nimble check</code> command.</p> <p>The <code>develop</code> command has a list of options:</p> <ul> <li><code>-p, --path path</code> - Specifies the path whether the packages should be cloned.</li> <li><code>-c, --create [path]</code> - Creates an empty develop file with the name <code>nimble.develop</code> in the current directory, or, if a path is present, to the given directory with a given name.</li> <li><code>-a, --add path</code> - Adds the package at the given path to the <code>nimble.develop</code> file.</li> <li><code>-r, --removePath path</code> - Removes the package at the given path from the <code>nimble.develop</code> file.</li> <li><code>-n, --removeName path</code> - Removed the package with the given name from the <code>nimble.develop</code> file.</li> <li><code>-i, --include file</code> - Includes a develop file into the current directory's one.</li> <li><code>-e, --exclude file</code> - Excludes a develop file from the current directory's one.</li> <li><code>--withDependencies</code> - Clones for develop also the dependencies of the packages for which the develop command is executed.</li> <li><code>--developFile</code> - Changes the name of the develop file which to be manipulated.   It is useful for creating a free develop file which is not associated with any project intended for inclusion in some other develop file.</li> <li><code>-g, --global</code> - Creates an old style link file in the special <code>links</code> directory.   It is read by Nim to be able to use global develop mode packages.   Nimble uses it as a global develop file if a local one does not exist.</li> </ul> <p>The options for manipulation of the develop files could be given only when executing <code>develop</code> command from some package's directory, unless <code>--developFile</code> option with a name of develop file is explicitly given.</p> <p>Because the develop files are user-specific and they contain local file system paths they must not be committed. (Running <code>nimble setup</code> takes care of this by adding <code>nimble.develop</code> to the <code>.gitignore</code> file.)</p>"},{"location":"workflow.html#nimble-sync","title":"<code>nimble sync</code>","text":"<p>The <code>nimble sync</code> command will synchronize develop mode dependencies with the content of the lock file. If the revision specified in the lock file is not found locally, it tries to fetch it from the configured remotes. If it is present on multiple branches, it tries to stay on the current one, and if can't, it prefers local branches rather than remote-tracking ones. If found on more than one branch, it gives the user a choice whether to switch.</p> <p>Sync operation will also download non-develop mode dependencies versions described in the lock file if they are not already present in the Nimble cache.</p> <p>If the <code>-l, --listOnly</code> option is given then the command only lists development mode dependencies whose working copies are out of sync, without actually syncing them and without downloading missing non-develop mode dependencies.</p>"},{"location":"workflow.html#example","title":"Example","text":"<p>Starting from a <code>myPackage</code> project we used as an example in creating Nimble packages guide, first we will add some dependencies to the <code>myPackage.nimble</code> file:</p> <pre><code>...\n\n# Dependencies\n\nrequires \"nim &gt;= 2.0.0\"\nrequires \"nimibook == 0.3.1\"\nrequires \"itertools == 0.3.0\"\n\n...\n</code></pre> <p>Now we run <code>nimble setup</code> to see if we already have all needed dependencies or if there is something that needs to be downloaded. This command also creates/updates <code>nimble.paths</code> and <code>config.nims</code> files.</p> <pre><code>$ nimble setup\n  Verifying dependencies for myPackage@0.1.0\n     Info:  Dependency on nimibook@0.3.1 already satisfied\n  Verifying dependencies for nimibook@0.3.1\n     Info:  Dependency on nimib@&gt;= 0.3.7 already satisfied\n  Verifying dependencies for nimib@0.3.10\n     Info:  Dependency on fusion@&gt;= 1.2 already satisfied\n  Verifying dependencies for fusion@1.2\n     Info:  Dependency on markdown@&gt;= 0.8.1 already satisfied\n  Verifying dependencies for markdown@0.8.7\n     Info:  Dependency on mustache@&gt;= 0.2.1 already satisfied\n  Verifying dependencies for mustache@0.4.3\n     Info:  Dependency on parsetoml@&gt;= 0.7.0 already satisfied\n  Verifying dependencies for parsetoml@0.7.1\n     Info:  Dependency on jsony@&gt;= 1.1.5 already satisfied\n  Verifying dependencies for jsony@1.1.5\n     Info:  Dependency on jsony@&gt;= 1.1.5 already satisfied\n  Verifying dependencies for jsony@1.1.5\n Installing itertools@0.3.0\nDownloading https://github.com/narimiran/itertools using git\n  Verifying dependencies for itertools@0.3.0\n Installing itertools@0.3.0\n  Success:  itertools installed successfully.\n     Info:  \"nimble.paths\" is generated.\n     Info:  \"config.nims\" is set up.\n</code></pre> <p>With all the dependencies installed, we can now create a lock file by running <code>nimble lock</code>:</p> <pre><code>$ nimble lock\n     Info:  Generating the lock file...\n  Verifying dependencies for myPackage@0.1.0\n     Info:  Dependency on nimibook@0.3.1 already satisfied\n  Verifying dependencies for nimibook@0.3.1\n     Info:  Dependency on nimib@&gt;= 0.3.7 already satisfied\n  Verifying dependencies for nimib@0.3.10\n     Info:  Dependency on fusion@&gt;= 1.2 already satisfied\n  Verifying dependencies for fusion@1.2\n     Info:  Dependency on markdown@&gt;= 0.8.1 already satisfied\n  Verifying dependencies for markdown@0.8.7\n     Info:  Dependency on mustache@&gt;= 0.2.1 already satisfied\n  Verifying dependencies for mustache@0.4.3\n     Info:  Dependency on parsetoml@&gt;= 0.7.0 already satisfied\n  Verifying dependencies for parsetoml@0.7.1\n     Info:  Dependency on jsony@&gt;= 1.1.5 already satisfied\n  Verifying dependencies for jsony@1.1.5\n     Info:  Dependency on jsony@&gt;= 1.1.5 already satisfied\n  Verifying dependencies for jsony@1.1.5\n     Info:  Dependency on itertools@0.3.0 already satisfied\n  Verifying dependencies for itertools@0.3.0\n  Success:  The lock file is generated.\n</code></pre> <p>We can run <code>nimble check</code> to verify everything is working properly:</p> <pre><code>$ nimble check\n  Success:  The package \"myPackage\" is valid.\n</code></pre> <p>If you don't need to update and/or modify your dependencies, your job is done. You can commit the <code>nimble.lock</code> file to make sure other developers, when they work on your package, use the exact same dependencies as you.</p> <p>On the other hand, if you want to fix a bug in a dependency which manifests in your own package, or you want to see if an updated version of some dependency will still work with your package, the <code>nimble develop</code> command will come handy.</p> <p>For our example, let's say we want to update the <code>itertools</code> dependency from version <code>0.3.0</code> to version <code>0.4.0</code>. We will put <code>itertools</code> in the develop mode, which will clone its git repo to a subdirectory of our package:</p> <pre><code>$ nimble develop itertools\nDownloading https://github.com/narimiran/itertools using git\n  Verifying dependencies for itertools@0.4.0\n  Success:  \"itertools\" set up in develop mode successfully to \"/home/user/myPackage/itertools\".\n  Success:  The package \"itertools@0.4.0\" at path \"/home/user/myPackage/itertools\"\n            is added to the develop file \"nimble.develop\".\n     Info:  \"nimble.paths\" is updated.\n</code></pre> <p>If you check the contents of <code>nimble.paths</code>, you will notice that the path for <code>itertools</code> is no more in <code>~/.nimble/pkgs2</code> directory (where the version 0.3.0 is), but it has the following value:</p> <pre><code>...\n--path:\"/home/user/myPackage/itertools/src\"\n...\n</code></pre> <p>We can now run our tests, which will use the updated version of <code>itertools</code> to see if everything still works as expected.</p> <p>Running <code>nimble check</code> now will correctly warn us that our working copy and the lock file are not synchronized:</p> <pre><code>$ nimble check\n    Error:  Some of package's develop mode dependencies are invalid.\n        ... Package \"itertools\" at \"/home/user/myPackage/itertools\" has not synced working copy..\n     Hint:  You have to call `nimble sync` to synchronize your develop mode dependencies working copies with the latest lock file.\n   Failure: Validation failed.\n</code></pre> <p>There are two paths we can take to synchronize them. One is, as it says in the hint above, to put the development version at the state written in the lock file (in our case, to checkout version 0.3.0), by running <code>nimble sync</code>. The other option is to update the lock file (to use version 0.4.0) by running <code>nimble lock</code>.</p> <p>If we run <code>nimble lock</code> at this point, we will get an error, reminding us that in <code>myPackage.nimble</code> we still have <code>requires \"itertools == 0.3.0\"</code>, which we need to manually update to <code>0.4.0</code>. After we change the version number in the <code>.nimble</code> file, we can successfully run <code>nimble lock</code>:</p> <pre><code>$ nimble lock\n     Info:  Updating the lock file...\n  Verifying dependencies for myPackage@0.1.0\n     Info:  Dependency on nimibook@0.3.1 already satisfied\n  Verifying dependencies for nimibook@0.3.1\n     Info:  Dependency on nimib@&gt;= 0.3.7 already satisfied\n  Verifying dependencies for nimib@0.3.10\n     Info:  Dependency on fusion@&gt;= 1.2 already satisfied\n  Verifying dependencies for fusion@1.2\n     Info:  Dependency on markdown@&gt;= 0.8.1 already satisfied\n  Verifying dependencies for markdown@0.8.7\n     Info:  Dependency on mustache@&gt;= 0.2.1 already satisfied\n  Verifying dependencies for mustache@0.4.3\n     Info:  Dependency on parsetoml@&gt;= 0.7.0 already satisfied\n  Verifying dependencies for parsetoml@0.7.1\n     Info:  Dependency on jsony@&gt;= 1.1.5 already satisfied\n  Verifying dependencies for jsony@1.1.5\n     Info:  Dependency on jsony@&gt;= 1.1.5 already satisfied\n  Verifying dependencies for jsony@1.1.5\n     Info:  Dependency on itertools@0.4.0 already satisfied\n  Verifying dependencies for itertools@0.4.0\n  Success:  The lock file is updated.\n</code></pre> <p>Here are the changes in the <code>nimble.lock</code> file:</p> <pre><code>--- a/nimble.lock\n+++ b/nimble.lock\n@@ -12,13 +12,13 @@\n       }\n     },\n     \"itertools\": {\n-      \"version\": \"0.3.0\",\n-      \"vcsRevision\": \"b0f6bb887c39bc7730f45abb72f7e9edd4714a66\",\n+      \"version\": \"0.4.0\",\n+      \"vcsRevision\": \"06c4de8b6b124368be269b00ecd0b34a3731739f\",\n       \"url\": \"https://github.com/narimiran/itertools\",\n       \"downloadMethod\": \"git\",\n       \"dependencies\": [],\n       \"checksums\": {\n-        \"sha1\": \"adaadfebd990a33d5e25df2fd0ce45a762af1003\"\n+        \"sha1\": \"e98b828dbee752fb6f22cb3fe9fd00c13a2514f5\"\n       }\n     },\n     \"jsony\": {\n</code></pre> <p>Running <code>nimble check</code> confirms everything is synchronized:</p> <pre><code>$ nimble check\n  Success:  The package \"myPackage\" is valid.\n</code></pre> <p>We can now commit the changes in <code>myPackage.nimble</code> and <code>nimble.lock</code> files, so that our package uses updated dependencies and other developers are able to use the exact versions as we are running locally.</p> <p>If you are that \"other developer\" who is also working on the same package with your own develop-mode dependencies, and the package is updated by your colleague in the way described above, after you run <code>git pull</code> you will also need to run <code>nimble sync</code> to get synchronize the new version of the lockfile and your local dependencies.</p>"}]}